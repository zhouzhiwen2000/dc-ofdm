-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/HDLTx/full_tx_ip_src_tone_mapping.vhd
-- Created: 2024-09-01 16:46:29
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: full_tx_ip_src_tone_mapping
-- Source Path: HDLTx/full_tx/payload_full/tone_mapping
-- Hierarchy Level: 2
-- Model version: 4.102
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.full_tx_ip_src_full_tx_pac.ALL;

ENTITY full_tx_ip_src_tone_mapping IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        data_in                           :   IN    std_logic;
        ctrl_in_start                     :   IN    std_logic;
        ctrl_in_end                       :   IN    std_logic;
        ctrl_in_valid                     :   IN    std_logic;
        bits_per_subcarrier               :   IN    std_logic_vector(3 DOWNTO 0);  -- ufix4
        len_in_ofdm_symbols               :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        new_frame                         :   IN    std_logic;
        data_out                          :   OUT   std_logic;
        ctrl_out_start                    :   OUT   std_logic;
        ctrl_out_end                      :   OUT   std_logic;
        ctrl_out_valid                    :   OUT   std_logic
        );
END full_tx_ip_src_tone_mapping;


ARCHITECTURE rtl OF full_tx_ip_src_tone_mapping IS

  -- Component Declarations
  COMPONENT full_tx_ip_src_Compare_To_Constant
    PORT( u                               :   IN    std_logic_vector(25 DOWNTO 0);  -- ufix26
          y                               :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT full_tx_ip_src_Sample_Control_Bus_Creator_block4
    PORT( In1                             :   IN    std_logic;
          In2                             :   IN    std_logic;
          In3                             :   IN    std_logic;
          Out1_start                      :   OUT   std_logic;
          Out1_end                        :   OUT   std_logic;
          Out1_valid                      :   OUT   std_logic
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : full_tx_ip_src_Compare_To_Constant
    USE ENTITY work.full_tx_ip_src_Compare_To_Constant(rtl);

  FOR ALL : full_tx_ip_src_Sample_Control_Bus_Creator_block4
    USE ENTITY work.full_tx_ip_src_Sample_Control_Bus_Creator_block4(rtl);

  -- Signals
  SIGNAL bits_per_subcarrier_unsigned     : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Data_Type_Conversion_out1        : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Delay11_out1                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Gain_out1                        : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Delay8_reg                       : vector_of_unsigned10(0 TO 1);  -- ufix10 [2]
  SIGNAL Delay8_out1                      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL len_in_ofdm_symbols_unsigned     : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Delay9_reg                       : vector_of_unsigned16(0 TO 2);  -- ufix16 [3]
  SIGNAL Delay9_out1                      : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Product1_out1                    : unsigned(25 DOWNTO 0);  -- ufix26
  SIGNAL Delay5_reg                       : vector_of_unsigned26(0 TO 1);  -- ufix26 [2]
  SIGNAL count_hit                        : unsigned(25 DOWNTO 0);  -- ufix26
  SIGNAL count_hit_1                      : unsigned(25 DOWNTO 0);  -- ufix26
  SIGNAL Delay7_out1_valid                : std_logic;
  SIGNAL valid                            : std_logic;
  SIGNAL Delay10_out1                     : std_logic;
  SIGNAL count_step                       : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL count_reset                      : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Delay7_out1_end                  : std_logic;
  SIGNAL end_rsvd                         : std_logic;
  SIGNAL Subtract_out1                    : unsigned(25 DOWNTO 0);  -- ufix26
  SIGNAL Relational_Operator_out1         : std_logic;
  SIGNAL Logical_Operator_out1            : std_logic;
  SIGNAL Switch2_out1                     : std_logic;
  SIGNAL hold_end                         : std_logic;
  SIGNAL count                            : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL count_1                          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL hold_end_1                       : std_logic;
  SIGNAL enable                           : std_logic;
  SIGNAL count_2                          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL count_3                          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL count_4                          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Subtract_sub_cast                : signed(32 DOWNTO 0);  -- sfix33
  SIGNAL Subtract_sub_cast_1              : signed(32 DOWNTO 0);  -- sfix33
  SIGNAL Subtract_sub_temp                : signed(32 DOWNTO 0);  -- sfix33
  SIGNAL Compare_To_Constant_out1         : std_logic;
  SIGNAL Logical_Operator5_out1           : std_logic;
  SIGNAL Logical_Operator6_out1           : std_logic;
  SIGNAL Switch2_out1_1                   : std_logic;
  SIGNAL hold_end_2                       : std_logic;
  SIGNAL Delay4_out1                      : std_logic;
  SIGNAL Delay_reg                        : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL Delay_out1                       : std_logic;
  SIGNAL Constant_out1                    : std_logic;
  SIGNAL Switch_out1                      : std_logic;
  SIGNAL Delay7_out1_start                : std_logic;
  SIGNAL start                            : std_logic;
  SIGNAL Delay2_out1                      : std_logic;
  SIGNAL Logical_Operator7_out1           : std_logic;
  SIGNAL new_frame_hold                   : std_logic;
  SIGNAL Unit_Delay2_out1                 : std_logic;
  SIGNAL Logical_Operator1_out1           : std_logic;
  SIGNAL Delay3_out1                      : std_logic;
  SIGNAL hold_end_3                       : std_logic;
  SIGNAL Logical_Operator3_out1           : std_logic;
  SIGNAL Logical_Operator2_out1           : std_logic;
  SIGNAL Sample_Control_Bus_Creator_out1_start : std_logic;
  SIGNAL Sample_Control_Bus_Creator_out1_end : std_logic;
  SIGNAL Sample_Control_Bus_Creator_out1_valid : std_logic;

BEGIN
  u_Compare_To_Constant : full_tx_ip_src_Compare_To_Constant
    PORT MAP( u => std_logic_vector(Subtract_out1),  -- ufix26
              y => Compare_To_Constant_out1
              );

  u_Sample_Control_Bus_Creator : full_tx_ip_src_Sample_Control_Bus_Creator_block4
    PORT MAP( In1 => Delay3_out1,
              In2 => Logical_Operator3_out1,
              In3 => Logical_Operator2_out1,
              Out1_start => Sample_Control_Bus_Creator_out1_start,
              Out1_end => Sample_Control_Bus_Creator_out1_end,
              Out1_valid => Sample_Control_Bus_Creator_out1_valid
              );

  bits_per_subcarrier_unsigned <= unsigned(bits_per_subcarrier);

  Data_Type_Conversion_out1 <= resize(bits_per_subcarrier_unsigned, 8);

  Delay11_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay11_out1 <= to_unsigned(16#00#, 8);
      ELSIF enb = '1' THEN
        Delay11_out1 <= Data_Type_Conversion_out1;
      END IF;
    END IF;
  END PROCESS Delay11_process;


  Gain_out1 <= resize(to_unsigned(16#C2#, 8) * Delay11_out1, 10);

  Delay8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay8_reg <= (OTHERS => to_unsigned(16#000#, 10));
      ELSIF enb = '1' THEN
        Delay8_reg(0) <= Gain_out1;
        Delay8_reg(1) <= Delay8_reg(0);
      END IF;
    END IF;
  END PROCESS Delay8_process;

  Delay8_out1 <= Delay8_reg(1);

  len_in_ofdm_symbols_unsigned <= unsigned(len_in_ofdm_symbols);

  Delay9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay9_reg <= (OTHERS => to_unsigned(16#0000#, 16));
      ELSIF enb = '1' THEN
        Delay9_reg(0) <= len_in_ofdm_symbols_unsigned;
        Delay9_reg(1 TO 2) <= Delay9_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS Delay9_process;

  Delay9_out1 <= Delay9_reg(2);

  Product1_out1 <= Delay8_out1 * Delay9_out1;

  Delay5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay5_reg <= (OTHERS => to_unsigned(16#0000000#, 26));
      ELSIF enb = '1' THEN
        Delay5_reg(0) <= Product1_out1;
        Delay5_reg(1) <= Delay5_reg(0);
      END IF;
    END IF;
  END PROCESS Delay5_process;

  count_hit <= Delay5_reg(1);

  count_hit_1 <= count_hit;

  c_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay7_out1_valid <= '0';
      ELSIF enb = '1' THEN
        Delay7_out1_valid <= ctrl_in_valid;
      END IF;
    END IF;
  END PROCESS c_process;


  valid <= Delay7_out1_valid;

  Delay10_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay10_out1 <= '0';
      ELSIF enb = '1' THEN
        Delay10_out1 <= valid;
      END IF;
    END IF;
  END PROCESS Delay10_process;


  -- Free running, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  count_step <= to_unsigned(1, 32);

  count_reset <= to_unsigned(0, 32);

  c_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay7_out1_end <= '0';
      ELSIF enb = '1' THEN
        Delay7_out1_end <= ctrl_in_end;
      END IF;
    END IF;
  END PROCESS c_1_process;


  end_rsvd <= Delay7_out1_end;

  
  Relational_Operator_out1 <= '1' WHEN Subtract_out1 <= resize(Delay8_out1, 26) ELSE
      '0';

  Logical_Operator_out1 <= end_rsvd AND Relational_Operator_out1;

  hold_end <= Switch2_out1;

  count_1 <= count + count_step;

  hold_end_1 <= Switch2_out1;

  enable <= Delay10_out1 OR hold_end_1;

  
  count_2 <= count WHEN enable = '0' ELSE
      count_1;

  
  count_3 <= count_2 WHEN new_frame = '0' ELSE
      count_reset;

  HDL_Counter_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        count <= to_unsigned(0, 32);
      ELSIF enb = '1' THEN
        count <= count_3;
      END IF;
    END IF;
  END PROCESS HDL_Counter_process;


  count_4 <= count;

  Subtract_sub_cast <= signed(resize(count_hit_1, 33));
  Subtract_sub_cast_1 <= signed(resize(count_4, 33));
  Subtract_sub_temp <= Subtract_sub_cast - Subtract_sub_cast_1;
  Subtract_out1 <= unsigned(Subtract_sub_temp(25 DOWNTO 0));

  Logical_Operator5_out1 <= Compare_To_Constant_out1 AND hold_end;

  Logical_Operator6_out1 <= Logical_Operator5_out1 OR Logical_Operator_out1;

  
  Switch2_out1_1 <= Switch2_out1 WHEN Logical_Operator6_out1 = '0' ELSE
      Logical_Operator_out1;

  reduced_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Switch2_out1 <= '0';
      ELSIF enb = '1' THEN
        Switch2_out1 <= Switch2_out1_1;
      END IF;
    END IF;
  END PROCESS reduced_process;


  hold_end_2 <= Switch2_out1;

  Delay4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay4_out1 <= '0';
      ELSIF enb = '1' THEN
        Delay4_out1 <= hold_end_2;
      END IF;
    END IF;
  END PROCESS Delay4_process;


  Delay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        Delay_reg(0) <= data_in;
        Delay_reg(1) <= Delay_reg(0);
      END IF;
    END IF;
  END PROCESS Delay_process;

  Delay_out1 <= Delay_reg(1);

  Constant_out1 <= '0';

  
  Switch_out1 <= Delay_out1 WHEN Delay4_out1 = '0' ELSE
      Constant_out1;

  c_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay7_out1_start <= '0';
      ELSIF enb = '1' THEN
        Delay7_out1_start <= ctrl_in_start;
      END IF;
    END IF;
  END PROCESS c_2_process;


  start <= Delay7_out1_start;

  Delay2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay2_out1 <= '0';
      ELSIF enb = '1' THEN
        Delay2_out1 <= start;
      END IF;
    END IF;
  END PROCESS Delay2_process;


  Logical_Operator7_out1 <= Delay2_out1 OR new_frame;

  Unit_Delay2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Unit_Delay2_out1 <= '0';
      ELSIF enb = '1' THEN
        Unit_Delay2_out1 <= new_frame_hold;
      END IF;
    END IF;
  END PROCESS Unit_Delay2_process;


  
  new_frame_hold <= Unit_Delay2_out1 WHEN Logical_Operator7_out1 = '0' ELSE
      new_frame;

  Logical_Operator1_out1 <= new_frame_hold AND start;

  Delay3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay3_out1 <= '0';
      ELSIF enb = '1' THEN
        Delay3_out1 <= Logical_Operator1_out1;
      END IF;
    END IF;
  END PROCESS Delay3_process;


  hold_end_3 <= Switch2_out1;

  Logical_Operator3_out1 <= Compare_To_Constant_out1 AND hold_end_3;

  Logical_Operator2_out1 <= Delay10_out1 OR hold_end;

  data_out <= Switch_out1;

  ctrl_out_start <= Sample_Control_Bus_Creator_out1_start;

  ctrl_out_end <= Sample_Control_Bus_Creator_out1_end;

  ctrl_out_valid <= Sample_Control_Bus_Creator_out1_valid;

END rtl;

